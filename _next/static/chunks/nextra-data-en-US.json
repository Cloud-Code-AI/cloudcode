{"/contact_us":{"title":"Contact Us","data":{"":"If you have any questions or need further assistance, please feel free to contact us at support@cloudcode.ai.You can also schedule a demo call here, or connect with any founder on their social media:Demo Call: https://cloudcode.ai/book-a-demo.htmlSaurav Panda\nhttps://github.com/sauravpanda\nhttps://www.linkedin.com/in/pandasaurav/Shreyash Gupta\nhttps://github.com/shreyashkgupta\nhttps://www.linkedin.com/in/shreyashkgupta/"}},"/contributing":{"title":"Contributing","data":{"":"We welcome contributions from the community! If you'd like to contribute to CloudCode, please follow these steps:","fork-the-repository#Fork the repository":"Visit the CloudCode repository on GitHub and click on the Fork button to create a copy of the repository under your own GitHub account.","create-a-new-branch#Create a new branch":"Navigate to your local copy of the CloudCode repository and create a new branch for your feature or fix:\ncheckout -b feature/my-feature\nReplace my-feature with a descriptive name for your feature or fix.","commit-your-changes#Commit your changes":"Make the necessary changes to the codebase and commit them:\ngit commit -m 'Add some feature'\nReplace Add some feature with a concise and meaningful commit message.","push-to-the-branch#Push to the branch":"git push origin feature/my-feature","open-a-pull-request#Open a pull request":"Go to the GitHub page of your forked repository. You should see a prompt to create a new pull request from your recently pushed branch.Select the base branch (usually main or master) of the original CloudCode repository.\nSelect your branch (feature/my-feature) as the compare branch.\nProvide a clear title and description for your pull request detailing the changes introduced.","collaborate-and-iterate#Collaborate and Iterate":"Your pull request will be reviewed by the maintainers of CloudCode. Be prepared to address any feedback or suggestions they may have. Collaborate on refining your changes until they are ready to be merged into the main repository.Thank you for contributing to CloudCode!"}},"/feature_request":{"title":"Feature Requests","data":{"":"We welcome feature requests from our users, as they help us improve our product and provide a better experience for everyone. If you have an idea for a new feature or an improvement to an existing one, please follow the steps below to submit a feature request.","step-1-check-existing-requests#Step 1: Check Existing Requests":"Before creating a new feature request, we recommend checking the existing ones in our GitHub Discussions to see if your idea has already been suggested. If you find a similar request, you can upvote it or add your thoughts to the existing discussion.","step-2-create-a-new-discussion#Step 2: Create a New Discussion":"If your feature request is unique, you can create a new discussion by following these steps:\nGo to the GitHub Discussions page for our repository.\nClick on the \"New Discussion\" button.\nSelect the \"Feature Request\" category from the dropdown menu.\nProvide a clear and descriptive title for your feature request.\nIn the discussion body, provide a detailed description of your proposed feature or enhancement. Include the following information:\nA brief overview of the feature\nThe problem it solves or the benefit it provides\nAny relevant use cases or scenarios\nMockups, diagrams, or examples (if applicable)\nAny additional context or information that could be helpful","step-3-engage-with-the-community#Step 3: Engage with the Community":"Once you've created your feature request, others in the community can view, comment, and react to it. We encourage you to engage with the community, answer questions, and provide additional details or clarifications as needed.","step-4-wait-for-review-and-feedback#Step 4: Wait for Review and Feedback":"Our team regularly reviews the feature requests in the discussions. We may ask for additional information, provide feedback, or share our plans regarding the implementation of the feature. Please be patient, as we carefully evaluate each request and prioritize them based on various factors.","step-5-stay-informed#Step 5: Stay Informed":"We will update the discussion with any progress or decisions made regarding your feature request. If your request is accepted for implementation, we will provide updates on the development timeline and release plans.Thank you for your contributions and for helping us make our product better!"}},"/features/code_review":{"title":"Code Review","data":{"code-review-by-kaizen#Code Review by Kaizen":"The Code Review is an AI-powered tool that automatically reviews and provides feedback on code changes in your pull requests (PRs). It helps streamline the code review process and ensures high code quality across your codebase.","how-it-works#How it Works":"Diff Analysis: When you create or update a pull request, the Code Review Bot analyzes the code changes (diff) and generates detailed feedback based on the modified code snippets.\nOrganized Feedback: The bot's feedback is organized into topics or categories like performance, security, code style, or documentation, making it easier to navigate and prioritize the comments.\nConfidence Levels: Each review comment includes a confidence level (critical, high, medium, low), indicating the perceived importance or severity of the issue.\nContextual Information: The reviews provide context-specific details like file names, line numbers, code snippets, and explanations for the suggested changes.\nPR Description Generation: The bot can generate a descriptive summary of the code changes, helping you better document your pull requests.","using-the-code-review-bot#Using the Code Review Bot":"Create or Update a Pull Request: The Code Review Bot will automatically analyze the code changes and generate a review.\nReview the Feedback: The bot's feedback will be shared as a comment on your pull request, organized by topics and confidence levels.\nEngage with the Bot: You can interact with the bot, provide additional context, or request clarification on its feedback.\nIterate and Improve: As you work with the bot, it will learn from your responses and improve the quality of its reviews over time.","benefits#Benefits":"Improved Code Quality: Catch potential issues and receive suggestions for improvements early in the development process.\nTime Savings: Automated reviews reduce the time and effort required for manual code reviews.\nConsistent Standards: Ensure consistent application of coding standards, best practices, and guidelines across your codebase.\nKnowledge Sharing: The bot's reviews serve as a knowledge-sharing mechanism, providing insights that can benefit your entire development team.","limitations#Limitations":"AI Limitations: While advanced, the bot may still have limitations in understanding complex code or context-specific nuances.\nHuman Oversight: The bot's feedback should be considered a complementary tool to human code reviews, not a complete replacement.\nWith the Code Review Bot, you can streamline your code review process, maintain high code quality, and leverage the power of AI to enhance your development workflow."}},"/features/e2e_testing":{"title":"E2e Testing","data":{"e2e-ui-testing-with-playwright#E2E UI Testing with Playwright":"The E2E UI Testing feature is designed to streamline the process of creating and maintaining comprehensive end-to-end tests for web applications using the Playwright testing framework. It leverages advanced language models to generate robust and maintainable test scripts that can be seamlessly integrated into a CI/CD pipeline.","key-features#Key Features":"Test Plan Generation: The feature analyzes the application requirements or specifications and automatically generates a comprehensive test plan, covering various user flows and scenarios.\nPlaywright Test Script Generation: Based on the test plan, the feature generates Playwright test scripts written in Python 3.9, following best practices and industry standards.\nPage Object Model: The generated scripts implement the Page Object Model (POM) design pattern, promoting code reusability, maintainability, and separation of concerns.\nWeb Element Interaction: The scripts leverage Playwright's powerful features for interacting with web elements, such as clicking buttons, filling out forms, and navigating between pages.\nVisual Testing: The feature utilizes Playwright's capabilities to capture screenshots and videos during test execution, enabling visual validation and debugging.","usage#Usage":"Provide Web URL: To generate E2E UI tests, provide the URL of the web application you want to test.\nTest Generation: The feature will analyze the web application's content, identify different UI modules, and generate appropriate Playwright test scripts for each module.\nTest Execution: The generated test scripts can be executed locally or integrated into a CI/CD pipeline for automated testing during the development lifecycle.\nTest Reporting: After test execution, the feature provides detailed reports, including test results, captured screenshots, and videos for failed tests, facilitating debugging and issue resolution.\nContinuous Integration: As the web application evolves, the feature can regenerate or update the test scripts to ensure they remain aligned with the latest changes and requirements.\nYou can find an example here","benefits#Benefits":"Accelerated Test Development: By leveraging advanced language models, the feature significantly accelerates the process of creating comprehensive E2E UI tests.\nMaintainability: The generated scripts follow best practices and industry standards, promoting code maintainability and extensibility.\nReusability: The implementation of the Page Object Model design pattern enhances code reusability and modularization.\nContinuous Quality Assurance: The seamless integration with CI/CD pipelines enables continuous testing and quality assurance throughout the software development lifecycle.\nVisual Validation: The ability to capture screenshots and videos during test execution aids in visual validation and issue identification.\nScalability: The feature supports data-driven testing and parallelization strategies, enabling scalable and efficient test execution.\nWith the E2E UI Testing feature, you can streamline the creation and maintenance of robust end-to-end tests for your web applications, ensuring comprehensive coverage, accelerating the testing process, and fostering a culture of continuous quality assurance within your development workflow"}},"/features/ui_review":{"title":"UI Review","data":{"ui-reviewer#UI Reviewer":"The UI Reviewer feature is powered by kaizen and provides feedback to improve the user experience and accessibility of UI components.","how-it-works#How it Works:":"Input the HTML code of your UI components.\nThe UI Reviewer leverages advanced language models to analyze the code and generate actionable feedback organized in a JSON format.\nYou can find an example here","using-the-ui-reviewer#Using the UI Reviewer:":"Gather and input the HTML code of the UI components you want to review.\nTrigger the UI Reviewer to receive organized feedback.\nImplement the suggested solutions to enhance user experience and accessibility.","benefits#Benefits:":"Improved User Experience\nAccessibility Compliance\nStreamlined Review Process\nContinuous Improvement","limitations#Limitations:":"AI Limitations: Understanding complex UI patterns or context-specific nuances.\nHuman Oversight: AI feedback should complement human review and testing.\nThe UI Reviewer uses AI to enhance the user experience and accessibility of UI components and fosters continuous improvement in your development workflow."}},"/features/work_summary":{"title":"Work Summary Generator","data":{"":"The Work Summary Generator is a tool that creates easy-to-understand summaries of code changes for non-technical stakeholders and founders.","how-it-works#How it works:":"Provide a Git diff representing the code changes to be summarized.\nThe tool uses advanced language models to analyze the diff and generate a detailed summary.\nThe summary includes a high-level overview, sectional breakdown, plain language explanations, feature highlights, impact analysis, and visual aids.\nThe tool ensures a consistent, readable structure.\nYou can find an example here","using-the-work-summary-generator#Using the Work Summary Generator:":"Generate a Git diff representing the code changes.\nTrigger the generator to create a user-friendly summary.\nShare the summary with stakeholders for better communication and understanding.\nUse the summary as a basis for discussions and decision-making.","benefits#Benefits:":"Bridge the gap between technical and non-technical stakeholders.\nKeep stakeholders engaged and informed about development progress.\nProvide a user-friendly way for non-technical stakeholders to track development progress.\nStreamline the reporting process with automatically generated work summaries.\nWith the Work Summary Generator, you can effectively communicate the value and progress of your development efforts to non-technical stakeholders, fostering better collaboration and alignment throughout the project lifecycle."}},"/getting_started":{"title":"Getting Started","data":{"":"You can start using Cloud Code AI in two different ways:","cloud-hosted-solution-recommended#Cloud Hosted Solution (Recommended)":"Utilize our cloud-hosted, scalable application at https://beta.cloudcode.ai to quickly access and leverage Cloud Code AI's capabilities without setting up your own infrastructure. This option is ideal for immediate use and simplifies the deployment process.","self-hosted-deployment#Self-Hosted Deployment":"Deploy your own instance of the open-source Cloud Code project by following the installation instructions provided in our documentation. Follow the steps outlined in the installation guide to set up Cloud Code AI on your infrastructure.Choose the option that best fits your needs and start accelerating your software development with Cloud Code AI today!"}},"/":{"title":"Index","data":{"":"Welcome to the Kaizen documentation! This resource will guide you through utilizing Kaizen to enhance your software development journey — from code reviews and testing automation to ensuring the security and reliability of your applications.","about-kaizen#About Kaizen":"Kaizen is an open-source project that helps teams ensure quality in their software delivery by providing a suite of tools for code review, test generation, and end-to-end testing. It integrates with your existing code repositories and workflows, allowing you to streamline your software development process.","key-features#Key Features":"","end-to-end-testing-wip#End-to-End Testing [WIP]":"Kaizen generates comprehensive end-to-end tests based on your application's code and documentation. These tests ensure that your application functions correctly from start to finish, catching regressions and edge cases that may have been overlooked during development.","ui-testing-and-review#UI Testing and Review":"Kaizen can provide teams with helpful reviews for their UI and generate necessary tests to ensure that their website works as expected.","code-review#Code Review":"Kaizen automatically reviews pull requests, summarizes code changes and provides insightful feedback on potential issues or areas of improvement. It leverages advanced natural language processing techniques to understand the context and implications of the code changes."}},"/self_hosting_guide":{"title":"Self Hosting Guide","data":{"":"This guide outlines the steps to set up a self-hosted instance of CloudCode, which utilizes a GitHub App to perform various actions related to pull requests (PRs) and repository management.CloudCode allows you to run its API server locally or on your own infrastructure.","prerequisites#Prerequisites":"Before you begin, ensure you have the following prerequisites installed and configured on your system:\nGit: Version control system used to clone the CloudCode repository.\nPython: Required for using Poetry, a dependency manager used by CloudCode.\nDocker and Docker Compose: For deploying and managing containerized applications.\nGitHub Account: You'll need this to set up a GitHub App and configure permissions.","outline#Outline":"To create your own local version of CloudCode, follow along the guide to complete the following steps:\nClone the repository.\nInstall required dependencies.\nCreate a Github app.\nPrepare the configuration settings.\nDeploy the API."}},"/self_hosting_guide/clone_repository":{"title":"Clone Repository","data":{"":"Run the following command in your local machine:\ngit clone https://github.com/cloudcode/cloudcode.git\nThis command will clone the CloudCode repository from GitHub to your local machine."}},"/self_hosting_guide/deploy_api":{"title":"Deploy API","data":{"":"To deploy the CloudCode API using Docker Compose, follow these steps:\nMake sure you have Docker and Docker Compose installed on your system.\nNavigate to the CloudCode project directory:\ncd cloudcode\nRun the following command to start the API server and its dependencies using Docker Compose:\ndocker-compose up\nThis command will build and launch the Docker containers defined in the docker-compose.yml file. The API server for CloudCode will be deployed and accessible based on the configurations specified in the docker-compose.yml file.You can monitor the logs and access the API endpoints once the containers are up and running. Use Ctrl + C to stop the Docker Compose process when you're finished."}},"/self_hosting_guide/executing_tests":{"title":"Executing Tests","data":{"":"Once you have generated all the necessary tests, you can run all the tests in two ways:\nRun the following command to execute the tests.\n   PYTHONPATH=. poetry run python examples/basic/execute.py\nOR\nUse the default pytest module to execute all tests.\n    pytest -v .kaizen/tests/\nKaizen will generate all the tests and store them inside .kaizen/tests/"}},"/self_hosting_guide/generating_tests":{"title":"Generating Tests","data":{"":"Follow these steps to generate tests for your website.\nUpdate the URL in the file at examples/basic/generate.py - Line 5.\nRun the following command to generate tests.\n    PYTHONPATH=. poetry run python examples/basic/generate.py\nKaizen will generate all the tests and store them inside .kaizen/tests/"}},"/self_hosting_guide/install_dependencies":{"title":"Install Dependencies","data":{"":"To install dependencies for CloudCode, follow these steps:\nChange directory to the CloudCode project directory:\n   cd cloudcode\nUse Poetry to install the project dependencies:\n   poetry install\nThese commands will navigate you into the CloudCode project directory and then use Poetry to install the required dependencies specified in the project's pyproject.toml file."}},"/self_hosting_guide/prepare_configuration":{"title":"Prepare Configuration","data":{"":"To prepare for deployment, follow these steps to configure the necessary files:\nCopy Environment File:\nCreate a .env file by duplicating .env.example. This file will store environment variables required for the deployment process.\nStore GitHub App PEM File:\nEnsure the PEM file for the GitHub app is stored as GITHUB_APP_KEY.pem. This file is necessary for authentication and interaction with the GitHub platform during deployment.","configuring-features#Configuring Features":"You can adjust additional features by modifying the config.json file. This JSON file controls specific configurations related to the deployment process and application behavior.Make sure to update these files appropriately before proceeding with deployment."}},"/self_hosting_guide/setup_github_app":{"title":"Setup GitHub App","data":{"":"Follow these steps to set up your GitHub app:","registering-your-github-app#Registering Your GitHub App":"Access Developer Settings:\nClick on your profile photo in the upper-right corner of GitHub.\nGo to Settings and then click on Developer settings in the left sidebar.\nCreate a New GitHub App:\nUnder Developer settings, select GitHub Apps and click on New GitHub App.\nProvide App Details:\nEnter the following details for your app:\nGitHub App name: Choose a name for your app.\nHomepage URL: Specify the URL of your app (e.g., repository URL).\nWebhook URL: Enter the server URL where webhook requests will be sent.\nOptionally, set a Webhook secret for request validation.","configure-webhook-and-permissions#Configure Webhook and Permissions":"Activate Webhook:\nEnsure the \"Webhook\" toggle is set to Active.\nSet Permissions:\nIn the sidebar, navigate to Permissions & events.\nDefine Permissions:\nUnder Repository permissions, Organization permissions, and Account permissions, select required permissions such as:\nRepository Content\nPull Request\nMetadata\nCheck Runs","subscribe-to-events#Subscribe to Events":"Choose Events:\nUnder Subscribe to Events, select the webhook events your app needs to receive (e.g., \"Pull request\" events).\nBy following these steps, your GitHub app will be properly configured with the necessary permissions and event subscriptions for your project."}}}